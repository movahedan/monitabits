---
description: TypeScript, JavaScript, and React code standards - patterns and conventions
globs: ["**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx"]
alwaysApply: true
---

# Code Standards

## üö® CRITICAL: Self-Documenting Code

**Code should speak for itself. Naming and structure are your documentation.**

### Principles
- **No inline comments** - Code and names should be clear enough
- **No JSDoc unless absolutely necessary** - Only for complex modules, only on main file
- **Use spacing for organization** - Related code together (no blank line), separate logical groups (blank line)
- **Names explain intent** - Function/variable names should tell the story

### Code Organization Through Spacing
```ts
// ‚úÖ Good - Related code grouped, separated by blank lines
const fetchUser = async (userId: number): Promise<User> => {
  const response = await api.get(`/users/${userId}`);
  return response.data;
};

const updateUser = async (userId: number, data: UserUpdate): Promise<User> => {
  const response = await api.put(`/users/${userId}`, data);
  return response.data;
};

const validateUserInput = (input: unknown): input is UserUpdate => {
  return typeof input === 'object' && input !== null && 'name' in input;
};

// ‚ùå Bad - Comments explaining obvious code
// Fetch user from API
const fetchUser = async (userId: number): Promise<User> => {
  // Make API call
  const response = await api.get(`/users/${userId}`);
  // Return the data
  return response.data;
};
```

## Naming
```ts
// Files: kebab-case
// my-component.ts, user-service.ts

// Variables/functions: camelCase
const userAge = 25;
function calculateTotal() {}

// Classes/types/interfaces: PascalCase
class UserRepository {}
interface ApiResponse {}
type RecordOfArrays<TItem> = Record<string, TItem[]>;

// Constants: ALL_CAPS
const MAX_RETRY_COUNT = 3;

// Generic params: T prefix
type Repository<TEntity> = { findById(id: string): Promise<TEntity | null> };
```

## TypeScript Patterns
```ts
// ‚úÖ Explicit types, readonly by default
interface User {
  readonly id: number;
  readonly name: string;
  readonly email: string;
  readonly createdAt: Date;
}

// ‚úÖ Interface inheritance (not intersection types)
interface A { readonly a: string; }
interface B { readonly b: string; }
interface C extends A, B { readonly c: string; }

// ‚ùå Bad - intersection types (performance issues)
type C = A & B;

// ‚úÖ Discriminated unions (not bag of optionals)
type State<TData> =
  | { readonly status: "idle" }
  | { readonly status: "loading" }
  | { readonly status: "success"; readonly data: TData }
  | { readonly status: "error"; readonly error: Error };

// ‚ùå Bad - allows impossible states
type FetchingState<TData> = {
  status: "idle" | "loading" | "success" | "error";
  data?: TData;
  error?: Error;
};

// ‚úÖ as const objects (not enums)
const sizes = { xs: "EXTRA_SMALL", sm: "SMALL", md: "MEDIUM" } as const;
type Size = keyof typeof sizes;
type SizeValue = (typeof sizes)[Size];

// ‚ùå Avoid - numeric enums create reverse mappings
enum Direction { Up, Down, Left, Right }
Object.keys(Direction).length; // 8 (not 4!)

// ‚úÖ Explicit return types
function getUser(id: number): Promise<User | null> {}
async function createUser(data: CreateUserData): Promise<User> {}

// Exception: Components don't need explicit return types
const MyComponent = () => <div>Hello</div>;

// ‚úÖ Type guards
function isUser(obj: unknown): obj is User {
  return typeof obj === 'object' && obj !== null && 'id' in obj && 'name' in obj && 'email' in obj;
}

const processData = (data: unknown) => {
  if (isUser(data)) {
    console.log(data.name); // TypeScript knows data is User
  }
};

// ‚úÖ Union types for finite options
type ButtonVariant = 'primary' | 'secondary' | 'danger';
type ButtonSize = 'small' | 'medium' | 'large';

// ‚úÖ Utility types
type PartialUser = Partial<User>;
type UserWithoutId = Omit<User, 'id'>;
type UserKeys = keyof User;
```

## React Patterns
```tsx
// ‚úÖ Functional components with typed props
interface ButtonProps {
  readonly variant: 'primary' | 'secondary' | 'danger';
  readonly size: 'small' | 'medium' | 'large';
  readonly disabled?: boolean;
  readonly loading?: boolean;
  readonly children: React.ReactNode;
  readonly onClick?: () => void;
}

export const Button: React.FC<ButtonProps> = ({ variant, size, children, onClick }) => {
  return <button className={cn(variant, size)} onClick={onClick}>{children}</button>;
};

// ‚úÖ Custom hooks with explicit return types
interface UseUserOptions {
  readonly userId: number;
  readonly enabled?: boolean;
}

interface UseUserReturn {
  readonly user: User | null;
  readonly loading: boolean;
  readonly error: Error | null;
  readonly refetch: () => Promise<void>;
}

export const useUser = ({ userId, enabled = true }: UseUserOptions): UseUserReturn => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const fetchUser = async (): Promise<void> => {
    setLoading(true);
    setError(null);
    try {
      const data = await api.getUser(userId);
      setUser(data);
    } catch (err) {
      setError(err as Error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (enabled) fetchUser();
  }, [userId, enabled]);

  return { user, loading, error, refetch: fetchUser };
};

// ‚úÖ Event handlers with proper typing
const handleSubmit = (event: React.FormEvent<HTMLFormElement>): void => {
  event.preventDefault();
  const formData = new FormData(event.currentTarget);
  onSubmit(Object.fromEntries(formData));
};

const handleInputChange = (event: React.ChangeEvent<HTMLInputElement>): void => {
  const { name, value } = event.target;
  setFormData(prev => ({ ...prev, [name]: value }));
};

// ‚úÖ Early returns for conditional rendering
if (state.status === 'loading') return <LoadingSpinner />;
if (state.status === 'error') return <ErrorMessage error={state.error} />;
return <MainContent data={state.data} />;
```

## State Management
```tsx
// ‚úÖ Discriminated union state
type LoadingState<TData> =
  | { readonly status: 'idle' }
  | { readonly status: 'loading' }
  | { readonly status: 'success'; readonly data: TData }
  | { readonly status: 'error'; readonly error: string };

const useApiData = <TData,>(url: string) => {
  const [state, setState] = useState<LoadingState<TData>>({ status: 'idle' });

  const fetchData = useCallback(async (): Promise<void> => {
    setState({ status: 'loading' });
    try {
      const response = await fetch(url);
      const data = await response.json();
      setState({ status: 'success', data });
    } catch (error) {
      setState({ status: 'error', error: (error as Error).message });
    }
  }, [url]);

  useEffect(() => { fetchData(); }, [fetchData]);
  return { state, refetch: fetchData };
};
```

## Imports/Exports
```ts
// Import order: React ‚Üí Third-party ‚Üí Local (absolute) ‚Üí Relative
import React from 'react';
import { useState, useEffect, useCallback } from 'react';
import axios from 'axios';
import { useQuery } from '@tanstack/react-query';
import { User } from '@/types';
import { useAuth } from '@/hooks';
import { Button } from './Button';

// ‚úÖ Named exports (avoid default exports)
export function myFunction() {}
export { UserCard } from './UserCard';
export type { User, UserRole } from './types';

// Export organization: Types ‚Üí Components ‚Üí Hooks ‚Üí Utilities
export type { User, UserRole } from './types';
export { UserCard } from './UserCard';
export { useUser } from './hooks/useUser';
export { formatUser } from './utils/userUtils';

// Exception: Next.js pages require default export
export default function MyPage() {}
```

## Error Handling
```ts
// ‚úÖ Result types (prefer over throwing)
type Result<T, E extends Error> = 
  | { readonly ok: true; readonly value: T } 
  | { readonly ok: false; readonly error: E };

const parseJson = (input: string): Result<unknown, Error> => {
  try {
    return { ok: true, value: JSON.parse(input) };
  } catch (error) {
    return { ok: false, error: error as Error };
  }
};

// ‚úÖ Custom error types when throwing
class ValidationError extends Error {
  constructor(message: string, public readonly field: string) {
    super(message);
    this.name = 'ValidationError';
  }
}

class ApiError extends Error {
  constructor(message: string, public readonly statusCode: number) {
    super(message);
    this.name = 'ApiError';
  }
}

// ‚úÖ Try-catch for async operations
const handleSubmit = async (data: FormData): Promise<void> => {
  try {
    setLoading(true);
    const result = await api.submit(data);
    onSuccess(result);
  } catch (error) {
    console.error('Submit failed:', error);
    onError(error as Error);
  } finally {
    setLoading(false);
  }
};
```

## Utility Functions
```ts
// ‚úÖ Pure utility functions with clear types
export const debounce = <TArgs extends unknown[]>(
  fn: (...args: TArgs) => void,
  delay: number
): ((...args: TArgs) => void) => {
  let timeoutId: NodeJS.Timeout;
  return (...args: TArgs) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn(...args), delay);
  };
};

export const throttle = <TArgs extends unknown[]>(
  fn: (...args: TArgs) => void,
  limit: number
): ((...args: TArgs) => void) => {
  let inThrottle: boolean;
  return (...args: TArgs) => {
    if (!inThrottle) {
      fn(...args);
      inThrottle = true;
      setTimeout(() => (inThrottle = false), limit);
    }
  };
};

export const pick = <TObj extends Record<string, unknown>, TKey extends keyof TObj>(
  obj: TObj,
  keys: TKey[]
): Pick<TObj, TKey> => {
  const result = {} as Pick<TObj, TKey>;
  keys.forEach(key => { if (key in obj) result[key] = obj[key]; });
  return result;
};
```

## JSDoc (Rarely Needed)

**Only use JSDoc for complex modules where behavior is not self-evident. Usually only on the main file of a module.**

```ts
const calculateTotal = (price: number, taxRate: number): number => price * (1 + taxRate);

const formatUserName = (user: { firstName: string; lastName: string }): string => 
  `${user.firstName} ${user.lastName}`;
```

**When JSDoc is appropriate** (complex algorithms, non-obvious behavior):
```ts
/**
 * Calculates compound interest using continuous compounding formula
 * @param principal - Initial investment amount
 * @param rate - Annual interest rate as decimal
 * @param time - Time period in years
 * @returns Final amount after compounding
 */
const calculateCompoundInterest = (principal: number, rate: number, time: number): number => {
  return principal * Math.exp(rate * time);
};
```
