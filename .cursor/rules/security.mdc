---
description: Security patterns - ReDoS prevention, input validation, authentication
globs: ["**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx"]
alwaysApply: true
---

# Security

## ReDoS Prevention
```ts
// ‚ùå VULNERABLE - Catastrophic backtracking
/.*#(\d+).*/                    // Exponential runtime
/^(\w+)(?:\(([^)]+)\))?(!)?:\s*([^\r\n]+?)\s*$/  // Multiple backtracking issues
/.*\d+.*/                       // Greedy quantifiers with overlapping patterns
/(a+)+/                         // Nested quantifiers (evil regex)
/(a|aa)*/                       // Exponential backtracking
/.*#\d+.*/                      // Can match anywhere, causes backtracking

// ‚úÖ SECURE - Linear runtime guaranteed
/#(\d+)/                        // Direct match, no backtracking
/\d+/                           // Simple, direct match
/a+/                            // Single quantifier
/(?:a|aa)*/                     // Non-capturing, optimized
/\d{1,10}/                      // Bounded range
/^#\d+$/                        // Anchored to start/end
```

## Input Validation
```ts
// ‚úÖ Validate and sanitize
const validateEmail = (email: string): boolean => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);

const validatePassword = (password: string): boolean => {
  // At least 8 chars, 1 uppercase, 1 lowercase, 1 number
  return /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d@$!%*?&]{8,}$/.test(password);
};

const sanitizeHtml = (html: string): string => 
  html
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;');

// ‚ùå Bad - no length check (DoS risk)
const processInput = (input: string): string => input.replace(/[^\w\s#]/g, '');

// ‚úÖ Good - validate length first
const processInput = (input: string): string => {
  if (input.length > 1000) throw new Error('Input too long');
  return input.replace(/[^\w\s#]/g, '');
};
```

## Environment Variables
```ts
// ‚ùå Bad - no validation
const API_KEY = process.env.API_KEY;
const DATABASE_URL = process.env.DATABASE_URL;

// ‚úÖ Good - validate required env vars
const API_KEY = process.env.API_KEY;
if (!API_KEY) throw new Error('API_KEY is required');

const DATABASE_URL = process.env.DATABASE_URL;
if (!DATABASE_URL) throw new Error('DATABASE_URL is required');

const JWT_SECRET = process.env.JWT_SECRET;
if (!JWT_SECRET) throw new Error('JWT_SECRET is required');
```

## Authentication
```ts
// ‚ùå Bad - no error handling
const authenticate = (token: string) => jwt.verify(token, process.env.JWT_SECRET);

// ‚úÖ Good - JWT with proper error handling
const authenticate = async (token: string) => {
  try {
    return jwt.verify(token, process.env.JWT_SECRET);
  } catch (error) {
    throw new Error('Invalid token');
  }
};

// ‚úÖ Token refresh
const refreshToken = async (refreshToken: string) => {
  try {
    const response = await api.post('/auth/refresh', { refreshToken });
    return response.data.accessToken;
  } catch (error) {
    throw new Error('Token refresh failed');
  }
};

// ‚úÖ Safe regex with timeout
const safeRegexTest = async (pattern: RegExp, input: string): Promise<boolean> => {
  return await Promise.race([
    Promise.resolve(pattern.test(input)),
    new Promise<boolean>((_, reject) => setTimeout(() => reject(new Error('Regex timeout')), 1000))
  ]);
};
```

## SQL Injection Prevention
```ts
// ‚ùå Bad - vulnerable to SQL injection
const badQuery = `SELECT * FROM users WHERE id = ${userId}`;
const badQuery2 = `SELECT * FROM users WHERE name = '${userName}'`;

// ‚úÖ Good - parameterized queries
const getUserById = async (id: number) => {
  const query = 'SELECT * FROM users WHERE id = ?';
  const result = await db.execute(query, [id]);
  return result[0];
};

const getUserByName = async (name: string) => {
  const query = 'SELECT * FROM users WHERE name = ?';
  const result = await db.execute(query, [name]);
  return result[0];
};
```

## Regex Security Patterns
```ts
// ‚ùå Bad - greedy quantifier with overlapping patterns
const badPattern = /.*#\d+.*/;

// ‚úÖ Good - direct match
const goodPattern = /#\d+/;

// ‚ùå Bad - capturing group overhead
const badPattern = /(\w+)(\([^)]+\))/;

// ‚úÖ Good - non-capturing group
const goodPattern = /(\w+)(?:\([^)]+\))/;

// ‚ùå Bad - unbounded range
const badPattern = /\d+/;

// ‚úÖ Good - bounded range
const goodPattern = /\d{1,10}/;

// ‚ùå Bad - can match anywhere in string
const badPattern = /#\d+/;

// ‚úÖ Good - anchored to start/end
const goodPattern = /^#\d+$/;
```

## Rate Limiting & CORS
```ts
// ‚ùå Bad - no rate limiting
app.use('/api/', (req, res, next) => next());

// ‚úÖ Good - rate limiting
const rateLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100 // limit each IP to 100 requests per windowMs
});
app.use('/api/', rateLimiter);

// ‚ùå Bad - permissive CORS
app.use(cors());

// ‚úÖ Good - configured CORS
app.use(cors({
  origin: process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));
```

## Security Checklist
- [ ] No nested quantifiers like `(a+)+`
- [ ] No greedy + lazy combinations like `.*+?`
- [ ] No overlapping patterns that can backtrack
- [ ] Use bounded quantifiers when possible
- [ ] Test with malicious input (repeated characters)
- [ ] Input length limits to prevent DoS
- [ ] Set execution timeouts for regex operations
- [ ] Validate and sanitize input before processing
- [ ] All sensitive data in environment variables
- [ ] Proper CORS configuration
- [ ] Rate limiting implemented
- [ ] SQL injection prevention (parameterized queries)
- [ ] XSS protection in place

## üìö Resources

- [OWASP ReDoS Prevention](https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS)
- [Safe Regex Testing](https://github.com/davisjam/safe-regex)
- [Regex Performance](https://www.regular-expressions.info/performance.html)